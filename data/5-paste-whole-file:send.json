{
  "method": "edit",
  "params": {
    "method": "paste",
    "params": {
      "chars": "// Copyright 2016 The xi-editor Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport Foundation\nimport AppKit\n\n/// Env var used to specify a path for logging RPC messages.\n/// These logs can be used for profiling & debugging.\nlet XI_RPC_LOG = \"XI_CLIENT_RPC_LOG\"\n\n/// An error returned from core\nstruct RemoteError {\n    let code: Int\n    let message: String\n    let data: AnyObject?\n\n    init?(json: [String: AnyObject]) {\n        guard let code = json[\"code\"] as? Int,\n        let message = json[\"message\"] as? String else { return nil }\n        self.code = code\n        self.message = message\n        self.data = json[\"data\"]\n    }\n}\n\n/// The return value of a synchronous RPC\nenum RpcResult {\n    case error(RemoteError)\n    case ok(AnyObject)\n}\n\n/// A completion handler for a synchronous RPC\ntypealias RpcCallback = (RpcResult) -> ()\n\n/// Error tolerant wrapper for append-writing to a file.\nstruct FileWriter {\n    let path: URL\n    let handle: FileHandle\n\n    init?(path: String) {\n        let path = NSString(string: path).expandingTildeInPath\n        if FileManager.default.fileExists(atPath: path) {\n            print(\"file exists at \\(path), will not overwrite\")\n            return nil\n        }\n        self.path = URL(fileURLWithPath: path)\n        FileManager.default.createFile(atPath: self.path.path, contents: nil, attributes: nil)\n\n        do {\n            try self.handle = FileHandle(forWritingTo: self.path)\n        } catch let err as NSError {\n            print(\"error opening log file \\(err)\")\n            return nil\n        }\n    }\n\n    func write(bytes: Data) {\n        handle.write(bytes)\n    }\n}\n\n/// Protocol describing the general interface with core.\n/// Concrete implementations may be provided for different transport mechanisms, e.g. stdin/stdout, unix sockets, or FFI.\nprotocol RPCSending {\n    func sendRpcAsync(_ method: String, params: Any, callback: RpcCallback?)\n}\n\nclass StdoutRPCSender: RPCSending {\n\n    private let task = Process()\n    private var inHandle: FileHandle  // stdin of core process\n    private var recvBuf: Data\n    weak var client: XiClient?\n    private let rpcLogWriter: FileWriter?\n    private let errLogWriter: FileWriter?\n    private let appDelegate = NSApp.delegate as! AppDelegate\n\n    // RPC state\n    private var queue = DispatchQueue(label: \"com.levien.xi.CoreConnection\", attributes: [])\n    private var rpcIndex = 0\n    private var pending = Dictionary<Int, RpcCallback>()\n\n    init(path: String) {\n        if let rpcLogPath = ProcessInfo.processInfo.environment[XI_RPC_LOG] {\n            self.rpcLogWriter = FileWriter(path: rpcLogPath)\n            if self.rpcLogWriter != nil {\n                print(\"logging client RPC to \\(rpcLogPath)\")\n            }\n        } else {\n            self.rpcLogWriter = nil\n        }\n\n        if let errLogPath = appDelegate.errorLogDirectory?\n            .appendingPathComponent(appDelegate.defaultCoreLogName).path {\n            self.errLogWriter = FileWriter(path: errLogPath)\n            if self.errLogWriter != nil {\n                print(\"logging stderr to \\(errLogPath)\")\n            }\n        } else {\n            self.errLogWriter = nil\n        }\n\n        task.launchPath = path\n        task.arguments = []\n        let outPipe = Pipe()\n        task.standardOutput = outPipe\n        let inPipe = Pipe()\n        task.standardInput = inPipe\n        let errPipe = Pipe()\n        task.standardError = errPipe\n        inHandle = inPipe.fileHandleForWriting\n        recvBuf = Data()\n\n        outPipe.fileHandleForReading.readabilityHandler = { handle in\n            let data = handle.availableData\n            self.recvHandler(data)\n        }\n\n        errPipe.fileHandleForReading.readabilityHandler = { handle in\n            let data = handle.availableData\n            self.errLogWriter?.write(bytes: data)\n            if let errString = String(data: data, encoding: .utf8) {\n                print(errString, terminator: \"\")\n            }\n        }\n\n        // write to log on xi-core crash\n        task.terminationHandler = { _ in\n            // get current date to use as timestamp\n            let dateFormatter = DateFormatter()\n            let currentTime = Date()\n            dateFormatter.dateFormat = \"yyyy-MM-dd-HHMMSS\"\n            let timeStamp = dateFormatter.string(from: currentTime)\n\n            guard let tmpErrLog = self.appDelegate.errorLogDirectory?.appendingPathComponent(self.appDelegate.defaultCoreLogName),\n                let timestampedLog = self.appDelegate.errorLogDirectory?.appendingPathComponent(\"XiEditor_\\(timeStamp).log\")\n                else { return }\n            do {\n                try FileManager.default.moveItem(at: tmpErrLog, to: timestampedLog)\n            } catch let error as NSError {\n                print(\"failed to rename file with error: \\(error)\")\n            }\n            print(\"xi-core has closed, log saved to XiEditor_\\(timeStamp).log\")\n        }\n        task.launch()\n    }\n\n    private func recvHandler(_ data: Data) {\n        if data.count == 0 {\n            print(\"eof\")\n            return\n        }\n        let scanStart = recvBuf.count\n        recvBuf.append(data)\n        let recvBufLen = recvBuf.count\n\n        var newCount = 0\n        recvBuf.withUnsafeMutableBytes { (recvBufBytes: UnsafeMutablePointer<UInt8>) -> Void in\n            var i = 0\n            for j in scanStart..<recvBufLen {\n                // TODO: using memchr would probably be faster\n                if recvBufBytes[j] == UInt8(ascii:\"\\n\") {\n                    let bufferPointer = UnsafeBufferPointer(start: recvBufBytes.advanced(by: i), count: j + 1 - i)\n                    let dataPacket = Data(bufferPointer)\n                    handleRaw(dataPacket)\n                    i = j + 1\n                }\n            }\n            if i < recvBufLen {\n                memmove(recvBufBytes, recvBufBytes + i, recvBufLen - i)\n            }\n            newCount = recvBufLen - i\n        }\n        recvBuf.count = newCount\n    }\n\n    private func sendJson(_ json: Any) {\n        do {\n            var data = try JSONSerialization.data(withJSONObject: json, options: [])\n            let nl = [0x0a as UInt8]\n            data.append(nl, count: 1)\n\n\t\t\tif let rpcLogWriter = rpcLogWriter {\n\t\t\t\tvar mutdata = \"Send => \".data(using: .utf8)!\n\t\t\t\tmutdata.append(data)\n\t\t\t\trpcLogWriter.write(bytes: mutdata)\n\t\t\t}\n\n            inHandle.write(data as Data)\n        } catch _ {\n            print(\"error serializing to json\")\n        }\n    }\n\n    private func sendResult(id: Any, result: Any) {\n        let json = [\"id\": id, \"result\": result]\n        sendJson(json)\n    }\n\n    private func handleRaw(_ data: Data) {\n        Trace.shared.trace(\"handleRaw\", .rpc, .begin)\n        do {\n\t\t\tif let rpcLogWriter = rpcLogWriter,\n\t\t\t\tlet x = String(data: data, encoding: .utf8) {\n\t\t\t\trpcLogWriter.write(bytes: \"Recv <= \".appending(x).data(using: .utf8)!)\n\t\t\t}\n\n            let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments)\n            handleRpc(json)\n        } catch {\n            print(\"json error \\(error.localizedDescription)\")\n        }\n        Trace.shared.trace(\"handleRaw\", .rpc, .end)\n    }\n\n    /// handle a JSON RPC call. Determines whether it is a request, response or notification\n    /// and executes/responds accordingly\n    private func handleRpc(_ json: Any) {\n        guard let obj = json as? [String: AnyObject] else { fatalError(\"malformed json \\(json)\") }\n        if let index = obj[\"id\"] as? Int {\n            if obj[\"result\"] != nil || obj[\"error\"] != nil {\n                var callback: RpcCallback?\n                queue.sync {\n                    callback = self.pending.removeValue(forKey: index)\n                }\n                if let result = obj[\"result\"] {\n                    callback?(.ok(result))\n                } else if let errJson = obj[\"error\"] as? [String: AnyObject],\n                    let err = RemoteError(json: errJson) {\n                    callback?(.error(err))\n                } else {\n                    print(\"failed to parse response \\(obj)\")\n                }\n            } else {\n                self.handleRequest(json: obj)\n            }\n        } else {\n            self.handleNotification(json: obj)\n        }\n    }\n\n    private func handleRequest(json: [String: AnyObject]) {\n        guard let method = json[\"method\"] as? String, let params = json[\"params\"], let id = json[\"id\"]\n            else {\n                print(\"unknown json from core: \\(json)\")\n                return\n        }\n\n        switch method {\n        case \"measure_width\":\n            let args = params as! [[String: AnyObject]]\n            if let result = self.client?.measureWidth(args: args) {\n                self.sendResult(id: id, result: result)\n            }\n        default:\n            print(\"unknown request \\(method)\")\n        }\n    }\n\n    private func handleNotification(json: [String: AnyObject]) {\n        guard let method = json[\"method\"] as? String, let params = json[\"params\"]\n            else {\n                print(\"unknown json from core: \\(json)\")\n                return\n        }\n        let viewIdentifier = params[\"view_id\"] as? ViewIdentifier\n\n        switch method {\n        case \"update\":\n            let update = params[\"update\"] as! [String: AnyObject]\n            self.client?.update(viewIdentifier: viewIdentifier!, update: update, rev: nil)\n\n        case \"scroll_to\":\n            let line = params[\"line\"] as! Int\n            let col = params[\"col\"] as! Int\n            self.client?.scroll(viewIdentifier: viewIdentifier!, line: line, column: col)\n\n        case \"def_style\":\n            client?.defineStyle(style: params as! [String: AnyObject])\n\n        case \"plugin_started\":\n            let plugin = params[\"plugin\"] as! String\n            client?.pluginStarted(viewIdentifier: viewIdentifier!, pluginName: plugin)\n\n        case \"plugin_stopped\":\n            let plugin = params[\"plugin\"] as! String\n            client?.pluginStopped(viewIdentifier: viewIdentifier!, pluginName: plugin)\n\n        case \"available_themes\":\n            let themes = params[\"themes\"] as! [String]\n            client?.availableThemes(themes: themes)\n\n        case \"theme_changed\":\n            let name = params[\"name\"] as! String\n            let themeJson = params[\"theme\"] as! [String: AnyObject]\n            let theme = Theme(jsonObject: themeJson)\n            client?.themeChanged(name: name, theme: theme)\n        \n        case \"language_changed\":\n            let languageIdentifier = params[\"language_id\"] as! String\n            client?.languageChanged(\n                viewIdentifier: viewIdentifier!,\n                languageIdentifier: languageIdentifier\n            )\n            \n        case \"available_plugins\":\n            let plugins = params[\"plugins\"] as! [[String: AnyObject]]\n            client?.availablePlugins(viewIdentifier: viewIdentifier!, plugins: plugins)\n            \n        case \"available_languages\":\n            let languages = params[\"languages\"] as! [String]\n            client?.availableLanguages(languages: languages)\n\n        case \"update_cmds\":\n            let plugin = params[\"plugin\"] as! String\n            let cmdsJson = params[\"cmds\"] as! [[String: AnyObject]]\n            let cmds = cmdsJson.map { Command(jsonObject: $0) }\n                .filter { $0 != nil }\n                .map { $0! }\n\n            client?.updateCommands(viewIdentifier: viewIdentifier!,\n                                   plugin: plugin, commands: cmds)\n\n        case \"config_changed\":\n            let changes = params[\"changes\"] as! [String: AnyObject]\n            client?.configChanged(viewIdentifier: viewIdentifier!, changes: changes)\n\n        case \"alert\":\n            let message = params[\"msg\"] as! String\n            client?.alert(text: message)\n\n        case \"add_status_item\":\n            let source = params[\"source\"] as! String\n            let key = params[\"key\"] as! String\n            let value = params[\"value\"] as! String\n            let alignment = params[\"alignment\"] as! String\n            client?.addStatusItem(viewIdentifier: viewIdentifier!, source: source, key: key, value: value, alignment: alignment)\n\n        case \"update_status_item\":\n            let key = params[\"key\"] as! String\n            let value = params[\"value\"] as! String\n            client?.updateStatusItem(viewIdentifier: viewIdentifier!, key: key, value: value)\n\n        case \"remove_status_item\":\n            let key = params[\"key\"] as! String\n            client?.removeStatusItem(viewIdentifier: viewIdentifier!, key: key)\n\n        case \"show_hover\":\n            let requestIdentifier = params[\"request_id\"] as! Int\n            let result = params[\"result\"] as! String\n            client?.showHover(viewIdentifier: viewIdentifier!, requestIdentifier: requestIdentifier, result: result)\n\n        case \"find_status\":\n            let status = params[\"queries\"] as! [[String: AnyObject]]\n            client?.findStatus(viewIdentifier: viewIdentifier!, status: status)\n\n        case \"replace_status\":\n            let status = params[\"status\"] as! [String: AnyObject]\n            client?.replaceStatus(viewIdentifier: viewIdentifier!, status: status)\n\n        default:\n            print(\"unknown notification \\(method)\")\n        }\n    }\n\n    /// send an RPC request, returning immediately. The callback will be called when the\n    /// response comes in, likely from a different thread\n    func sendRpcAsync(_ method: String, params: Any, callback: RpcCallback? = nil) {\n        Trace.shared.trace(\"send \\(method)\", .rpc, .begin)\n        var req = [\"method\": method, \"params\": params] as [String : Any]\n        if let callback = callback {\n            queue.sync {\n                let index = self.rpcIndex\n                req[\"id\"] = index\n                self.rpcIndex += 1\n                self.pending[index] = callback\n            }\n        }\n        sendJson(req as Any)\n        Trace.shared.trace(\"send \\(method)\", .rpc, .end)\n    }\n\n    /// send RPC synchronously, blocking until return. Note: there is no ordering guarantee on\n    /// when this function may return. In particular, an async notification sent by the core after\n    /// a response to a synchronous RPC may be delivered before it.\n    func sendRpc(_ method: String, params: Any) -> RpcResult {\n        let semaphore = DispatchSemaphore(value: 0)\n        var result: RpcResult? = nil\n\n        sendRpcAsync(method, params: params) { (r) in\n            result = r\n            semaphore.signal()\n        }\n        let _ = semaphore.wait(timeout: .distantFuture)\n        return result!\n    }\n}\n"
    },
    "view_id": "view-id-2"
  }
}
